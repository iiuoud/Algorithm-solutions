## 栈、队列

### 20. 有效的括号

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

**示例 1：**

**输入：**s = "()"

**输出：**true

**示例 2：**

**输入：**s = "()[]{}"

**输出：**true

**示例 3：**

**输入：**s = "(]"

**输出：**false

**示例 4：**

**输入：**s = "([])"

**输出：**true

**示例 5：**

**输入：**s = "([)]"

**输出：**false

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
    var stack = [];
    for(const i of s){
        if(i==='(' || i==='{' || i==='[') {
            stack.push(i);
        } else {
            var end = stack[stack.length-1];
            if(end==='('&&i===')' || end==='{'&&i==='}'||end==='['&&i===']'){
                stack.pop()
            }
        }
    }
    if(stack.length===0) return true
    return false
};
```

### 1047. 删除字符串中所有相邻项

给出由小写字母组成的字符串 `s`，**重复项删除操作**会选择两个相邻且相同的字母，并删除它们。

在 `s` 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

**示例：**

```
输入："abbaca"
输出："ca"
解释：
例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。
```

```js
/**
 * @param {string} s
 * @return {string}
 */
var removeDuplicates = function(s) {
    var stack = []
    for(v of s){
        let prev=stack.pop()
        if(v!==prev){
            stack.push(prev);
            stack.push(v)
        }
    }
    return stack.join("");
};
```

### 71. 简化路径

给你一个字符串 `path` ，表示指向某一文件或目录的 Unix 风格 **绝对路径** （以 `'/'` 开头），请你将其转化为 **更加简洁的规范路径**。

在 Unix 风格的文件系统中规则如下：

- 一个点 `'.'` 表示当前目录本身。
- 此外，两个点 `'..'` 表示将目录切换到上一级（指向父目录）。
- 任意多个连续的斜杠（即，`'//'` 或 `'///'`）都被视为单个斜杠 `'/'`。
- 任何其他格式的点（例如，`'...'` 或 `'....'`）均被视为有效的文件/目录名称。

返回的 **简化路径** 必须遵循下述格式：

- 始终以斜杠 `'/'` 开头。
- 两个目录名之间必须只有一个斜杠 `'/'` 。
- 最后一个目录名（如果存在）**不能** 以 `'/'` 结尾。
- 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 `'.'` 或 `'..'`）。

返回简化后得到的 **规范路径** 。

**示例 1：**

**输入：**path = "/home/"

**输出：**"/home"

**解释：**

应删除尾随斜杠。

**示例 2：**

**输入：**path = "/home//foo/"

**输出：**"/home/foo"

**解释：**

多个连续的斜杠被单个斜杠替换。

**示例 3：**

**输入：**path = "/home/user/Documents/../Pictures"

**输出：**"/home/user/Pictures"

**解释：**

两个点 `".."` 表示上一级目录（父目录）。

**示例 4：**

**输入：**path = "/../"

**输出：**"/"

**解释：**

不可能从根目录上升一级目录。

**示例 5：**

**输入：**path = "/.../a/../b/c/../d/./"

**输出：**"/.../b/d"

**解释：**

`"..."` 在这个问题中是一个合法的目录名。

```js
/**
 * @param {string} path
 * @return {string}
 */
var simplifyPath = function (path) {
  const string = path.split('/');
  const stack = [];
  for (let i = 0; i < string.length; i++) {
    const str = string[i];
    if (str === '' || str === '.') {
      continue;
    }
    if (str === '..') {
      if (stack.length > 0) {
        stack.pop();
      }
      continue;
    }
    stack.push(str);
  }
  let res = '';
  while (stack.length) {
    res = '/' + stack.pop() + res;
  }
  return res === '' ? '/' : res;
};
```

### 225. 用队列实现栈

请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（`push`、`top`、`pop` 和 `empty`）。

实现 `MyStack` 类：

- `void push(int x)` 将元素 x 压入栈顶。
- `int pop()` 移除并返回栈顶元素。
- `int top()` 返回栈顶元素。
- `boolean empty()` 如果栈是空的，返回 `true` ；否则，返回 `false` 。 

**注意：**

- 你只能使用队列的标准操作 —— 也就是 `push to back`、`peek/pop from front`、`size` 和 `is empty` 这些操作。
- 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。

**示例：**

```
输入：
["MyStack", "push", "push", "top", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 2, 2, false]

解释：
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // 返回 2
myStack.pop(); // 返回 2
myStack.empty(); // 返回 False
```

#### 方法一：用两个队列实现

- 记录下栈顶元素，方便top方法直接返回
- `[this.queue1,this.queue2]=[this.queue2,this.queue1];`可以直接交换交换两个队列的角色

```js
var MyStack = function() {
    this.queue1=[];
    this.queue2=[];
    this.topElement=null;
};
/** 
 * @param {number} x
 * @return {void}
 */
MyStack.prototype.push = function(x) {
    this.queue1.push(x);
    this.topElement=x;
};
/**
 * @return {number}
 */
MyStack.prototype.pop = function() {
    if(this.queue1.length===0) return null;
    while(this.queue1.length>1){
        this.topElement=this.queue1.shift();
        this.queue2.push(this.topElement);
    }
    let poped=this.queue1.shift();
    [this.queue1,this.queue2]=[this.queue2,this.queue1];
    return poped;
};
/**
 * @return {number}
 */
MyStack.prototype.top = function() {
    return this.topElement;
};
/**
 * @return {boolean}
 */
MyStack.prototype.empty = function() {
    return this.queue1.length===0;
};
/** 
 * Your MyStack object will be instantiated and called as such:
 * var obj = new MyStack()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.empty()
 */
```

#### 方法二：用一个队列实现

```js
var MyStack = function() {
    this.queue=[];
    this.topElement=null;
};
MyStack.prototype.push = function(x) {
    this.topElement=x;
    this.queue.push(x);
};
MyStack.prototype.pop = function() {
    if(this.queue.length===0) return null;
    let len=this.queue.length;
    for(let i=0;i<len-1;i++){
        let cur=this.queue.shift();
      	this.topElement=cur;
        this.queue.push(cur);
    }
    let poped=this.queue.shift();
    return poped;
};
MyStack.prototype.top = function() {
    return this.topElement;
};
MyStack.prototype.empty = function() {
    return this.queue.length===0;
};
```

### 232. 用栈实现队列

- 使用两个栈，一个用于记录输入，一个用来输出
- 若输出栈为空，从输入栈中依次弹出到输出栈中，返回的队列首元素为输出栈的栈顶

```js
var MyQueue = function() {
    this.inStack=[];
    this.outStack=[];
};
/** 
 * @param {number} x
 * @return {void}
 */
MyQueue.prototype.push = function(x) {
    this.inStack.push(x);
};
/**
 * @return {number}
 */
MyQueue.prototype.pop = function() {
    if(this.outStack.length===0){
        while(this.inStack.length>0){
            this.outStack.push(this.inStack.pop());
        }
    }
    return this.outStack.pop();
};
/**
 * @return {number}
 */
MyQueue.prototype.peek = function() {
    if(this.outStack.length===0){
        while(this.inStack.length>0){
            this.outStack.push(this.inStack.pop());
        }
    }
    return this.outStack[this.outStack.length-1];
};
/**
 * @return {boolean}
 */
MyQueue.prototype.empty = function() {
    return this.inStack.length===0&&this.outStack.length===0
};
/** 
 * Your MyQueue object will be instantiated and called as such:
 * var obj = new MyQueue()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.peek()
 * var param_4 = obj.empty()
 */
```

### 150. 逆波兰表达式求值

给你一个字符串数组 `tokens` ，表示一个根据 [逆波兰表示法](https://baike.baidu.com/item/逆波兰式/128437) 表示的算术表达式。

请你计算该表达式。返回一个表示表达式值的整数。

**注意：**

- 有效的算符为 `'+'`、`'-'`、`'*'` 和 `'/'` 。
- 每个操作数（运算对象）都可以是一个整数或者另一个表达式。
- 两个整数之间的除法总是 **向零截断** 。
- 表达式中不含除零运算。
- 输入是一个根据逆波兰表示法表示的算术表达式。
- 答案及所有中间计算结果可以用 **32 位** 整数表示。

**示例 1：**

```
输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
```

**示例 2：**

```
输入：tokens = ["4","13","5","/","+"]
输出：6
解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
```

**示例 3：**

```
输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
输出：22
解释：该算式转化为常见的中缀算术表达式为：
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
```

```js
/**
 * @param {string[]} tokens
 * @return {number}
 */
var evalRPN = function(tokens) {
    let stack=[];
    let len=tokens.length;
    for(let i=0;i<len;i++){
        if(['+','-','/','*'].includes(tokens[i])){
            let a=stack.pop();
            let b=stack.pop();
            let result;
            switch(tokens[i]) {
                case '+': result = b + a; break;
                case '-': result = b - a; break; 
                case '*': result = b * a; break;
                case '/': result = Math.trunc(b / a); break;
            }
            stack.push(result);
        }
        else stack.push(Number(tokens[i]));
    }
    return Number(stack[0]);
};
```

### 151.  反转字符串中的单词

给你一个字符串 `s` ，请你反转字符串中 **单词** 的顺序。

**单词** 是由非空格字符组成的字符串。`s` 中使用至少一个空格将字符串中的 **单词** 分隔开。

返回 **单词** 顺序颠倒且 **单词** 之间用单个空格连接的结果字符串。

**注意：**输入字符串 `s`中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。

**示例 1：**

```
输入：s = "the sky is blue"
输出："blue is sky the"
```

**示例 2：**

```
输入：s = "  hello world  "
输出："world hello"
解释：反转后的字符串中不能存在前导空格和尾随空格。
```

**示例 3：**

```
输入：s = "a good   example"
输出："example good a"
解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。
```

```js
/**
 * @param {string} s
 * @return {string}
 */
var reverseWords = function(s) {
    let stack=[];
    let arr=s.split(" ").filter(word=>word!=="");

    for(let word of arr) stack.push(word);    
    let result=[];
    while(stack.length) result.push(stack.pop())
    return result.join(" ");
};
```

