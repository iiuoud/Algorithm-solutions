## 树

### 深度优先

从根节点出发，尽可能深的搜索树的节点

1. 访问根节点
2. 对根节点下的元素挨个进行深度优先搜索

### 广度优先

从根出发，优先访问离根节点近的节点

1. 新建一个队列，把根节点入队
2. 出队根节点
3. 把队头的子节点依次入队
4. 重复2和3步

### 100. 相同的树

给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg)

```
输入：p = [1,2,3], q = [1,2,3]
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg)

```
输入：p = [1,2], q = [1,null,2]
输出：false
```

**示例 3：**

![img](https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg)

```typescript
输入：p = [1,2,1], q = [1,1,2]
输出：false
```

#### 方法一：深度优先遍历

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */
var isSameTree = function(p, q) {
    if(!p&&!q) return true;
    if(!p||!q) return false;
    return p.val===q.val && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);
};
```

#### 方法二：广度优先遍历

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */
var isSameTree = function(p, q) {
    if(!p&&!q) return true;
    if(!p||!q) return false;
    let queue1=[p],queue2=[q];
    while(queue1.length){
        if (queue1.length!==queue2.length) return false;
        let size=queue1.length;
        for(let i=0;i<size; i++){
            let cur1=queue1.shift();
            let cur2=queue2.shift();
            if(cur1.val!==cur2.val) {
                return false;
            }
            if(cur1.left&&cur2.left){
                cur1.left&&queue1.push(cur1.left);
                cur2.left&&queue2.push(cur2.left);
            }else if(cur1.left||cur2.left){ //若都为空，则进入下一次循环
                return false;
            }
            
            if(cur1.right&&cur2.right){
                cur1.right&&queue1.push(cur1.right);
                cur2.right&&queue2.push(cur1.right);
            }else if(cur1.rigth||cur2.rigth){ //若都为空，则进入下一次循环
                return false;
            }
        }
    }
    return true;
};
```

### 101. 对称二叉树 

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

**示例 1：**

![img](https://pic.leetcode.cn/1698026966-JDYPDU-image.png)

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

**示例 2：**

![img](https://pic.leetcode.cn/1698027008-nPFLbM-image.png)

```
输入：root = [1,2,2,null,3,null,3]
输出：false
```

#### 方法一：递归

- 设有两个指针，一直向左遍历，一个向右遍历，每次判断这两个节点的值是否相等，和左节点的左子树与右节点的右子树，左节点的右子树与右节点的左子树是否相等

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
const check = (p,q) =>{
    if(!p&&!q) return true;
    if(!p||!q) return false;
    return p.val===q.val && check(p.left,q.right) && check(p.right,q.left);
}
var isSymmetric = function(root) {
    return check(root.left,root.right);
};
```

#### 方法二： 迭代

- 用一个队列来存储节点

- 初始时存放两次根节点，后续将对称位置的子节点成对入队：

  - u的左子节点vs v的右子节点

  - u的右子节点vs v的左子节点

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */

var isSymmetric = function(root) {
    if(!root) return true;
    let queue=[root,root];
    const check=()=>{
        while(queue.length) {
            let u=queue.shift();
            let v=queue.shift();
            if(u.val!==v.val) return false;
            if(u.left&&v.right) {
                queue.push(u.left);
                queue.push(v.right);
            } else if(u.left || v.right) return false;
            if(u.right&&v.left){
                queue.push(u.right);
                queue.push(v.left);
            } else if(u.right || v.left) return false;

        }
        return true;
    }
    return check();
};
```

### 617. 合并二叉树

给你两棵二叉树： `root1` 和 `root2` 。

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，**不为** null 的节点将直接作为新二叉树的节点。

返回合并后的二叉树。

**注意:** 合并过程必须从两个树的根节点开始。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/05/merge.jpg)

```
输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
输出：[3,4,5,5,4,null,7]
```

**示例 2：**

```
输入：root1 = [1], root2 = [1,2]
输出：[2,2]
```

#### 方法一：深度优先遍历

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root1
 * @param {TreeNode} root2
 * @return {TreeNode}
 */

var mergeTrees = function(root1, root2) {
    if(!root1) return root2;
    if(!root2) return root1;
    let newNode = new TreeNode(root1.val+root2.val);
    newNode.left=mergeTrees(root1.left,root2.left);
    newNode.right=mergeTrees(root1.right,root2.right);
    return newNode;
};
```

### 144. 二叉树的前序遍历

给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

**示例 1：**

**输入：**root = [1,null,2,3]

**输出：**[1,2,3]

**解释：**

![img](https://assets.leetcode.com/uploads/2024/08/29/screenshot-2024-08-29-202743.png)

**示例 2：**

**输入：**root = [1,2,3,4,5,null,8,null,null,6,7,9]

**输出：**[1,2,4,5,6,7,3,8,9]

**解释：**

![img](https://assets.leetcode.com/uploads/2024/08/29/tree_2.png)

**示例 3：**

**输入：**root = []

**输出：**[]

**示例 4：**

**输入：**root = [1]

**输出：**[1]

#### 方法一： 迭代

- 利用栈的先进后出原则，先存入右节点，再存入左节点

<img src="C:\Users\86137_hr4wcni\AppData\Roaming\Typora\typora-user-images\image-20251028165259835.png" alt="image-20251028165259835" style="zoom:33%;" />

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
    if(!root) return []
    let stack=[root],res=[];
    while(stack.length) {
        let cur=stack.pop();
        res.push(cur.val);
        cur.right && stack.push(cur.right);
        cur.left && stack.push(cur.left);
    }
    return res;
};
```

#### 方法二：递归

- 每次递归先操作左子树

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
    let arr=[];
    const fun = (node) =>{
        if(node){
            arr.push(node.val);
            fun(node.left);
            fun(node.right);
        }
    }
    fun(root);
    return arr;
};
```

### 111. 二叉树的最小深度

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明：**叶子节点是指没有子节点的节点。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：2
```

**示例 2：**

```
输入：root = [2,null,3,null,4,null,5,null,6]
输出：5
```

#### 方法一：深度优先遍历

- 设置一个depth值，依次查询左子树与右子树的深度，每次遍历树的深度就加1

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function(root) {
    if(!root) return 0;
    let depth=Infinity;
    if(!root.left&&!root.right) return 1;
    if(root.left) depth=Math.min(depth,1+minDepth(root.left));
    if(root.right) depth=Math.min(depth,1+minDepth(root.right));
    return depth;
};
```

#### 方法二：广度优先遍历

- 借助队列的先进先出原则，将每一层的节点依次放入队列中。
- 遍历时依次取出，若同时没有左右节点，则该层位最小高度。若有左节点或右节点，则将其加入队列中

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function(root) {
    if (!root) return 0
    let depth=1;
    let queue=[root];
    while(queue.length){
        let size=queue.length
        for(let i=0;i<size;i++){
            let cur=queue.shift();
            if(!cur.left&&!cur.right){
                return depth;
            }
        cur.left&& queue.push(cur.left);
        cur.right&& queue.push(cur.right);
        }
        depth++;
    }
};
```

### 114. 二叉树展开为链表

给你二叉树的根结点 `root` ，请你将它展开为一个单链表：

- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
- 展开后的单链表应该与二叉树 [**先序遍历**](https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin) 顺序相同。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg)

```
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [0]
输出：[0]
```

#### 方法一：迭代

- 利用栈的先进后出原则，获得先序遍历列表
- 直接修改root，不用写返回值

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {void} Do not return anything, modify root in-place instead.
 */
var flatten = function(root) {
    if(!root) return;
    let stack=[root], prev=null;
    while(stack.length) {
        let cur=stack.pop();

        if(prev) {
            prev.left=null;
            prev.right=cur;
        }
            
        if(cur.right) stack.push(cur.right);
        if(cur.left) stack.push(cur.left);

        prev=cur;
    }
};
```

### 94. 二叉树的中序遍历

#### 方法一：递归

更改了向arr推入数的时机

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
    if(!root) return [];
    let arr=[];
    const fun = (node) =>{
        if(node){
            fun(node.left);
            arr.push(node.val);
            fun(node.right);
        }
    }
    fun(root);
    return arr;
};
```

#### 方法二：迭代

- 中序遍历顺序为：左节点->根节点->右节点
- 设置了一个变量o，用于寻找最左节点，并压入栈中。这样可以保证最先输出的是左节点
- 从栈中取出元素，将其添加入输出数组中，并将根节点的右节点赋给o(如果这个元素没有右节点，那直接进行下一个从栈取出操作；如果有右节点，相当于输出了根节点，继续操作右节点)
- 重复进行以上操作

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
    if(!root) return [];
    let stack = [],res=[];
    let o=root;
    while(stack.length || o) {
        while(o) {
            stack.push(o);
            o=o.left;
        }
        let cur = stack.pop();
        res.push(cur.val);
        o=cur.right;
    }
    return res;
};
```

### 145. 二叉树的后序遍历

#### 方法一：递归

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function(root) {
    let res = [];
    const fun = (node) => {
        if(node) {
            fun(node.left);
            fun(node.right);
            res.push(node.val);
        }
    }
    fun(root);
    return res;
};
```

#### 方法二：迭代

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function(root) {
    if(!root) return [];
    let stack=[root], res=[];
    while(stack.length){
        let cur = stack.pop();
        res.unshift(cur.val);
        cur.left&&stack.push(cur.left);
        cur.right&&stack.push(cur.right);
    }
    return res;
};
```

### 104. 二叉树的最大深度

给定一个二叉树 `root` ，返回其最大深度。

二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg)

 

```
输入：root = [3,9,20,null,null,15,7]
输出：3
```

**示例 2：**

```
输入：root = [1,null,2]
输出：2
```

#### 方法一：深度优先遍历

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
    if(!root) return 0;
    let depth=1;
    depth=Math.max(depth,1+maxDepth(root.left));
    depth=Math.max(depth,1+maxDepth(root.right));
    return depth;
};
```

#### 方法二：广度优先遍历

- 最后的结果需要减1是因为for循环结束后，默认进入下一层的遍历。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
    if(!root) return 0;
    let queue=[root],depth=1;
    while(queue.length) {
        let size=queue.length
        for(let i=0; i<size; i++){
            let cur=queue.shift();
            cur.left&&queue.push(cur.left);
            cur.right&&queue.push(cur.right);
        }
        depth++;
    }
    return depth-1;
};
```

### 236. 二叉树的最近公共祖先

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

**示例 1：**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
```

**示例 3：**

```
输入：root = [1,2], p = 1, q = 2
输出：1
```

#### 方法一：递归

- 若找到改节点，返回该节点
- 若未找到，依次查询节点的左子树和右子树
- 若左右子树分别能搜到两个节点，说明该节点为最近公共祖先
- 若只有左子树找到了，找到一个后将不会继续进行查找，因为另一个节点一定在他的子树里，那么现在的这个找到的节点就是最近公共祖先；右子树找到了也同理。

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */

var lowestCommonAncestor = function(root, p, q) {
    if(!root || root===p || root === q) return root;
    let left=lowestCommonAncestor(root.left,p,q);
    let right=lowestCommonAncestor(root.right,p,q);
    if(left&&right) return root;
    return left || right; //返回的是查找结果，而不是左节点和右节点
};
```

### 543. 二叉树的直径

给你一棵二叉树的根节点，返回该树的 **直径** 。

二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。

两节点之间路径的 **长度** 由它们之间边数表示。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg" alt="img" style="zoom: 67%;" />

```
输入：root = [1,2,3,4,5]
输出：3
解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。
```

**示例 2：**

```
输入：root = [1,2]
输出：1
```

#### 方法一：递归

- 直径=经过的节点数-1
- 经过的节点数=某个节点的左子树深度+右子树深度 + 1(本身)
- 假设求根节点所在的最大直径
  - 计算以根节点的左子节点为根节点的最大深度
  - 计算以根节点的右子节点为根节点的最大深度
  - 两者相加

```js
var diameterOfBinaryTree = function(root) {
    //直径为：经过的节点数减1
    //查找每一个节点 左右子树深度的和
    const fun=(node)=>{
        if(!node) return 0
        let depth=1;
        depth=Math.max(depth, 1+fun(node.left));
        depth=Math.max(depth, 1+fun(node.right));
        return depth;
    }
    let depthl=fun(root.left);
    let depthr=fun(root.right);
    return depthl+depthr;
};
```

- 补充完遍历所有节点，存在大量的重复递归调用

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var diameterOfBinaryTree = function(root) {
    //直径为：经过的节点数减1
    //查找每一个节点 左右子树深度的和
    if(!root) return 0;
    const fun=(node)=>{
        if(!node) return 0
        let depth=1;
        depth=Math.max(depth, 1+fun(node.left));
        depth=Math.max(depth, 1+fun(node.right));
        return depth;
    }
    let depthl=fun(root.left);
    let depthr=fun(root.right);
    let maxLength=depthl+depthr;
    maxLength=Math.max(maxLength, diameterOfBinaryTree(root.left),diameterOfBinaryTree(root.right));
    return maxLength;
};
```

- 优化版：采用后续遍历

```js
var diameterOfBinaryTree = function(root) {
    let res=0;
    const fun=(node)=>{
      if(!node) return 0;
      let left=fun(node.left);
      let right=fun(node.right);
      res=Math.max(res,left+right);
      return 1+Math.max(left,right); //返回以当前节点为根节点的最大深度
    }
    return res;
};
```

<img src="C:\Users\86137_hr4wcni\AppData\Roaming\Typora\typora-user-images\image-20251030151414778.png" alt="image-20251030151414778" style="zoom:33%;" />

- 从左下角(2)开始更新最大直径

### 572. 另一棵树的子树

给你两棵二叉树 `root` 和 `subRoot` 。检验 `root` 中是否包含和 `subRoot` 具有相同结构和节点值的子树。如果存在，返回 `true` ；否则，返回 `false` 。

二叉树 `tree` 的一棵子树包括 `tree` 的某个节点和这个节点的所有后代节点。`tree` 也可以看做它自身的一棵子树。

**示例 1：**

<img src="https://pic.leetcode.cn/1724998676-cATjhe-image.png" alt="img" style="zoom:50%;" />

```
输入：root = [3,4,5,1,2], subRoot = [4,1,2]
输出：true
```

**示例 2：**

<img src="https://pic.leetcode.cn/1724998698-sEJWnq-image.png" alt="img" style="zoom: 50%;" />

```
输入：root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]
输出：false
```

#### 方法一：递归

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} subRoot
 * @return {boolean}
 */
var isSubtree = function(root, subRoot) {
    
    const isSameTree=(p,q)=>{
        if(!p&&!q) return true;
        if(!p||!q) return false;
        return p.val===q.val && isSameTree(p.left,q.left) && isSameTree(p.right,q.right);
    }

    const find=(node)=>{
        if(!node) return false; //叶子结点不会再包含树
        if(node.val===subRoot.val&&isSameTree(node,subRoot)) return true;
            
        return find(node.left) || find(node.right);
    }
    
    return find(root);
};
```

### 222. 完全二叉树的节点个数

给你一棵 **完全二叉树** 的根节点 `root` ，求出该树的节点个数。

[完全二叉树](https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin) 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 `h` 层（从第 0 层开始），则该层包含 `1~ 2h` 个节点。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/14/complete.jpg)

```
输入：root = [1,2,3,4,5,6]
输出：6
```

**示例 2：**

```
输入：root = []
输出：0
```

**示例 3：**

```
输入：root = [1]
输出：1
```

#### 方法一：广度优先遍历(通用)

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var countNodes = function(root) {
    if(!root) return 0;
    let queue=[root],count=0;
    while(queue.length) {
        let size=queue.length;
        for(let i=0;i<size;i++){
            let cur=queue.shift();
            count++;
            cur.left&&queue.push(cur.left);
            cur.right&&queue.push(cur.right);
        }
    }
    return count;
};
```

#### 方法二：递归+双指针

- 每次递归判断左右子树的高度是否相等
  - 相等：为满二叉树，节点数为2**n-1
  - 不相等：对该节点的左右子节点进行递归计算，总节点数为1+两边的递归结果

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var countNodes = function(root) {
    if(!root) return 0;
    let leftH=0,rightH=0;
    let leftNode=root,rightNode=root;
    while(leftNode){
        leftH++;
        leftNode=leftNode.left;
    }
    while(rightNode){
        rightH++;
        rightNode=rightNode.right;
    }
    if(leftH===rightH) return 2**leftH-1;
    return 1+countNodes(root.left)+countNodes(root.right);
};
```

### 257.  二叉树的所有路径

给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。

**叶子节点** 是指没有子节点的节点。 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg)

```
输入：root = [1,2,3,null,5]
输出：["1->2->5","1->3"]
```

**示例 2：**

```
输入：root = [1]
输出：["1"]
```

#### 方法一：深度优先遍历

- 每一次递归都进行路径的拼接

- 若为叶子结点则向数组中添加字符串，结束本次递归
- 若不是则继续向左子节点和右子节点进行递归

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {string[]}
 */
var binaryTreePaths = function(root) {
    const res=[];
    const fun=(node,path)=>{
        if(!node) return;
        const currentPath=path ? path+"->"+node.val : ""+node.val;
        if(!node.left&&!node.right) {
            res.push(currentPath);
            return;
        }
        fun(node.left,currentPath);
        fun(node.right,currentPath);
    }
    fun(root,"");
    return res;
};
```

### 102. 二叉树的层序遍历

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img" style="zoom:67%;" />

```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
```

**示例 2：**

```
输入：root = [1]
输出：[[1]]
```

**示例 3：**

```
输入：root = []
输出：[]
```

#### 方法一：广度优先遍历

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    if(!root) return [];
    let queue=[root],res=[];
    while(queue.length){
        let size=queue.length;
        let levelRes = [];
        for(let i=0;i<size;i++){
            let cur=queue.shift();
            levelRes.push(cur.val);
            cur.left&&queue.push(cur.left);
            cur.right&&queue.push(cur.right);
        }
        res.push(levelRes);
    }
    return res;
};
```

### 107. 二叉树的层序遍历 II

给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img" style="zoom:67%;" />

```
输入：root = [3,9,20,null,null,15,7]
输出：[[15,7],[9,20],[3]]
```

**示例 2：**

```
输入：root = [1]
输出：[[1]]
```

**示例 3：**

```
输入：root = []
输出：[]
```

#### 方法一：广度优先遍历

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrderBottom = function(root) {
    if(!root) return [];
    let queue=[root],res=[];
    while(queue.length){
        let size=queue.length;
        let levelRes = [];
        for(let i=0;i<size;i++){
            let cur=queue.shift();
            levelRes.push(cur.val);
            cur.left&&queue.push(cur.left);
            cur.right&&queue.push(cur.right);
        }
        res.unshift(levelRes);
    }
    return res;
};
```

### 199. 二叉树的右视图

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

**示例 1：**

**输入：**root = [1,2,3,null,5,null,4]

**输出：**[1,3,4]

**解释：**

<img src="https://assets.leetcode.com/uploads/2024/11/24/tmpd5jn43fs-1.png" alt="img" style="zoom:50%;" />

**示例 2：**

**输入：**root = [1,2,3,4,null,null,null,5]

**输出：**[1,3,4,5]

**解释：**

<img src="https://assets.leetcode.com/uploads/2024/11/24/tmpkpe40xeh-1.png" alt="img" style="zoom:50%;" />

**示例 3：**

**输入：**root = [1,null,3]

**输出：**[1,3]

**示例 4：**

**输入：**root = []

**输出：**[]

#### 方法一：层次遍历

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var rightSideView = function(root) {
    if(!root) return [];
    let queue=[root],res=[];
    while(queue.length) {
        let size=queue.length;
        for(let i=0;i<size;i++){
            let cur=queue.shift();
            if(i===size-1){
                res.push(cur.val);
            }
            cur.left&&queue.push(cur.left);
            cur.right&&queue.push(cur.right);
        }
    }
    return res;
};
```

### 637. 二叉树的层平均值

给定一个非空二叉树的根节点 `root` , 以数组的形式返回每一层节点的平均值。与实际答案相差 `10-5` 以内的答案可以被接受。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2021/03/09/avg1-tree.jpg" alt="img" style="zoom:67%;" />

```
输入：root = [3,9,20,null,null,15,7]
输出：[3.00000,14.50000,11.00000]
解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。
因此返回 [3, 14.5, 11] 。
```

**示例 2:**

<img src="https://assets.leetcode.com/uploads/2021/03/09/avg2-tree.jpg" alt="img" style="zoom:67%;" />

```
输入：root = [3,9,20,15,7]
输出：[3.00000,14.50000,11.00000]
```

#### 方法一：层次遍历

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var averageOfLevels = function(root) {
    if(!root) return [];
    let queue=[root],res=[];
    while(queue.length){
        let size=queue.length;
        let sum=0;
        for(let i=0;i<size;i++){
            let cur=queue.shift();
            sum+=cur.val;
            cur.left&&queue.push(cur.left);
            cur.right&&queue.push(cur.right);
        }
        sum = Number((sum / size).toFixed(5));
        res.push(sum);
    }
    return res;
};
```

### 116. 填充每个节点的下一个右侧节点指针

给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。

初始状态下，所有 next 指针都被设置为 `NULL`。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2019/02/14/116_sample.png)

```
输入：root = [1,2,3,4,5,6,7]
输出：[1,#,2,3,#,4,5,6,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。
```

**示例 2:**

```
输入：root = []
输出：[]
```

#### 方法一：层次遍历

```js
/**
 * // Definition for a _Node.
 * function _Node(val, left, right, next) {
 *    this.val = val === undefined ? null : val;
 *    this.left = left === undefined ? null : left;
 *    this.right = right === undefined ? null : right;
 *    this.next = next === undefined ? null : next;
 * };
 */

/**
 * @param {_Node} root
 * @return {_Node}
 */
var connect = function(root) {
    if(!root) return null;
    let queue=[root];
    while(queue.length){
        let size=queue.length;
        for(let i=0;i<size;i++){
            let cur=queue.shift();
            if(i<size-1) cur.next=queue[0];
            else cur.next=null;
            cur.left&&queue.push(cur.left);
            cur.right&&queue.push(cur.right); 
        }
    }
    return root;
};
```

### 429. N 叉树的层序遍历

给定一个 N 叉树，返回其节点值的*层序遍历*。（即从左到右，逐层遍历）。

树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png" alt="img" style="zoom: 50%;" />

```
输入：root = [1,null,3,2,4,null,5,6]
输出：[[1],[3,2,4],[5,6]]
```

**示例 2：**

<img src="https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png" alt="img" style="zoom:50%;" />

```
输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]
```

#### 方法一：层次遍历

```js
/**
 * // Definition for a _Node.
 * function _Node(val,children) {
 *    this.val = val;
 *    this.children = children;
 * };
 */

/**
 * @param {_Node|null} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    if(!root) return [];
    let queue=[root],res=[];
    while(queue.length){
        let size=queue.length;
        let levelRes = [];
        for(let i=0;i<size;i++){
            let cur=queue.shift();
            levelRes.push(cur.val);
            for(let i=0;i<cur.children.length;i++){
                queue.push(cur.children[i]);
            }
        }
        res.push(levelRes);
    }
    return res;
};
```

### 112. 路径总和

给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。

**叶子节点** 是指没有子节点的节点。

 

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" alt="img" style="zoom:67%;" />

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
解释：等于目标和的根节点到叶节点路径如上图所示。
```

**示例 2：**

<img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="img" style="zoom:67%;" />

```
输入：root = [1,2,3], targetSum = 5
输出：false
解释：树中存在两条根节点到叶子节点的路径：
(1 --> 2): 和为 3
(1 --> 3): 和为 4
不存在 sum = 5 的根节点到叶子节点的路径。
```

**示例 3：**

```
输入：root = [], targetSum = 0
输出：false
解释：由于树是空的，所以不存在根节点到叶子节点的路径。
```

#### 方法一：递归

- 结合寻找

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {boolean}
 */
var hasPathSum = function(root, targetSum) {
    if(!root) return false;
    const fun=(node,sum)=>{
        if(!node) return false;
        sum+=node.val;
        if(!node.left&&!node.right&&sum===targetSum) return true;
        return fun(node.left,sum) || fun(node.right,sum);
    }
    return fun(root,0)
};
```

### 404. 左叶子之和

给定二叉树的根节点 `root` ，返回所有左叶子之和。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2021/04/08/leftsum-tree.jpg" alt="img" style="zoom:67%;" />

```
输入: root = [3,9,20,null,null,15,7] 
输出: 24 
解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
```

**示例 2:**

```
输入: root = [1]
输出: 0
```

#### 方法一：递归

- 传一个isLeft值判断是否为左子结点

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var sumOfLeftLeaves = function(root) {
    if(!root) return 0;
    let sum=0;
    const fun=(node,isLeft)=>{
        if(!node) return;
        if(!node.left&&!node.right){
            if(isLeft) sum+=node.val;
            return;
        }
        fun(node.left,true);
        fun(node.right,false);
    }
    fun(root,false);
    return sum;
};
```

### 98. 验证二叉搜索树

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左子树只包含 **严格小于** 当前节点的数。
- 节点的右子树只包含 **严格大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="img" style="zoom:67%;" />

```
输入：root = [2,1,3]
输出：true
```

**示例 2：**

<img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" alt="img" style="zoom:67%;" />

```
输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值是 5 ，但是右子节点的值是 4 。
```

#### 方法一：递归

- 传递当前节点若要满足二叉搜索树的取值范围
- 左树：一层一层缩小范围
- 右数：一层一层扩大范围

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isValidBST = function(root) {
    const validate=(node,min,max)=>{
        if(!node) return true;
        if((min!==null&&node.val<=min) || (max!==null&&node.val>=max)) return false;
        return validate(node.left,min,node.val)&&validate(node.right,node.val,max);
    }
    return validate(root,null,null)
};
```

### 99. 恢复二叉搜索树

给你二叉搜索树的根节点 `root` ，该树中的 **恰好** 两个节点的值被错误地交换。*请在不改变其结构的情况下，恢复这棵树* 。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2020/10/28/recover1.jpg" alt="img" style="zoom:67%;" />

```
输入：root = [1,3,null,null,2]
输出：[3,1,null,null,2]
解释：3 不能是 1 的左孩子，因为 3 > 1 。交换 1 和 3 使二叉搜索树有效。
```

**示例 2：**

<img src="https://assets.leetcode.com/uploads/2020/10/28/recover2.jpg" alt="img" style="zoom:67%;" />

```
输入：root = [3,1,4,null,null,2]
输出：[2,1,4,null,null,3]
解释：2 不能在 3 的右子树中，因为 2 < 3 。交换 2 和 3 使二叉搜索树有效。
```

#### 方法一：中序遍历

- 错误1：出现了两对不满足前小后大，需要交换第一对的第一个元素与第二对的第二个元素。
- 错误2：只出现一对不满足前小后大，交换这一对元素即可。

<img src="C:\Users\86137_hr4wcni\AppData\Roaming\Typora\typora-user-images\image-20251030224933824.png" alt="image-20251030224933824" style="zoom:50%;" />

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {void} Do not return anything, modify root in-place instead.
 */
var recoverTree = function(root) {
    let prev=new TreeNode(-Infinity);
    let err1,err2=null;
    const inOrder=(node)=>{
        if(!node) return;
        inOrder(node.left);
        if(prev.val>=node.val && !err1) err1=prev;
        if(prev.val>=node.val && err1!==null) err2=node;
        prev=node;
        inOrder(node.right);
    }
    inOrder(root);
    let temp=err1.val;
    err1.val=err2.val;
    err2.val=temp;
}
```

