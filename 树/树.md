## 树

### 100. 相同的树

给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg)

```
输入：p = [1,2,3], q = [1,2,3]
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg)

```
输入：p = [1,2], q = [1,null,2]
输出：false
```

**示例 3：**

![img](https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg)

```typescript
输入：p = [1,2,1], q = [1,1,2]
输出：false
```

#### 方法一：深度优先遍历

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */
var isSameTree = function(p, q) {
    if(p===null&&q===null){
        return true;
    }else if(p===null || q===null){
        return false;
    }else if(p.val!==q.val){
        return false
    }else{
        return isSameTree(p.left,q.left)&&isSameTree(p.right,q.right)
    }
};
```

### 101. 对称二叉树 

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

**示例 1：**

![img](https://pic.leetcode.cn/1698026966-JDYPDU-image.png)

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

**示例 2：**

![img](https://pic.leetcode.cn/1698027008-nPFLbM-image.png)

```
输入：root = [1,2,2,null,3,null,3]
输出：false
```

#### 方法一：递归

- 设有两个指针，一直向左遍历，一个向右遍历，每次判断这两个节点的值是否相等，和左节点的左子树与右节点的右子树，左节点的右子树与右节点的左子树是否相等

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */

var check = function(p,q) {
    if(!q && !p) return true;
    if(!q || !p) return false;
    return p.val===q.val && check(p.left,q.right) && check(p.right,q.left);
}

var isSymmetric = function(root) {
    return check(root.left, root.right);
};
```

#### 方法二： 迭代

- 用一个队列来存储节点

- 初始时存放两次根节点，后续将对称位置的子节点成对入队：

  - u的左子节点vs v的右子节点

  - u的右子节点vs v的左子节点

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */

var check = function(v,u) {
    var q = [];
    q.push(v);
    q.push(u);

    while(q.length) {
        u=q.shift();
        v=q.shift();
        if(!u && !v) continue;
        if((!u || !v) || (u.val!==v.val)) return false; 

        q.push(u.left);
        q.push(v.right);

        q.push(u.right);
        q.push(v.left);
    }
    return true;
}

var isSymmetric = function(root) {
    return check(root, root);
};
```

### 617. 合并二叉树

给你两棵二叉树： `root1` 和 `root2` 。

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，**不为** null 的节点将直接作为新二叉树的节点。

返回合并后的二叉树。

**注意:** 合并过程必须从两个树的根节点开始。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/05/merge.jpg)

```
输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
输出：[3,4,5,5,4,null,7]
```

**示例 2：**

```
输入：root1 = [1], root2 = [1,2]
输出：[2,2]
```

#### 方法一：深度优先遍历

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root1
 * @param {TreeNode} root2
 * @return {TreeNode}
 */

var mergeTrees = function(root1, root2) {
    if(!root1) return root2;
    if(!root2) return root1;

    let merge = new TreeNode(root1.val+root2.val);
    merge.left=mergeTrees(root1.left,root2.left);
    merge.right=mergeTrees(root1.right,root2.right);
    return merge;    
};
```

### 144. 二叉树的前序遍历

给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

**示例 1：**

**输入：**root = [1,null,2,3]

**输出：**[1,2,3]

**解释：**

![img](https://assets.leetcode.com/uploads/2024/08/29/screenshot-2024-08-29-202743.png)

**示例 2：**

**输入：**root = [1,2,3,4,5,null,8,null,null,6,7,9]

**输出：**[1,2,4,5,6,7,3,8,9]

**解释：**

![img](https://assets.leetcode.com/uploads/2024/08/29/tree_2.png)

**示例 3：**

**输入：**root = []

**输出：**[]

**示例 4：**

**输入：**root = [1]

**输出：**[1]

#### 方法一： 迭代

- 利用栈的先进后出原则，先存入右节点，再存入左节点

<img src="C:\Users\86137_hr4wcni\AppData\Roaming\Typora\typora-user-images\image-20251028165259835.png" alt="image-20251028165259835" style="zoom:33%;" />

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
    if(!root) return [];

    let result = [], stack = [];
    stack.push(root);
    while(stack.length) {
        let cur = stack.pop();
        result.push(cur.val);
        if(cur.right) stack.push(cur.right);
        if(cur.left) stack.push(cur.left);

    }
    return result;
};
```

#### 方法二：递归

- 每次递归先操作左子树

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
    let result=[];
    pre(root,result);
    return result;
};
var pre = function(root,arr){
    if(!root) return;
    arr.push(root.val);
    
    pre(root.left,arr);
    pre(root.right,arr);
    return arr;
}
```

### 111. 二叉树的最小深度

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明：**叶子节点是指没有子节点的节点。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：2
```

**示例 2：**

```
输入：root = [2,null,3,null,4,null,5,null,6]
输出：5
```

#### 方法一：深度优先遍历

- 设置一个depth值，依次查询左子树与右子树的深度，每次遍历树的深度就加1

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function(root) {
    if(!root) return 0;

    let depth = Infinity;
    if(root.left) {
        depth = Math.min(depth, 1+minDepth(root.left));
    }
    if(root.right) {
        depth = Math.min(depth, 1+minDepth(root.right));
    }
    if(!root.left && !root.right) return 1;
    return depth;
};
```

#### 方法二：广度优先遍历

- 借助队列的先进先出原则，将每一层的节点依次放入队列中。
- 遍历时依次取出，若同时没有左右节点，则该层位最小高度。若有左节点或右节点，则将其加入队列中

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function(root) {
    if(!root) return 0;

    let queue = [root];
    let depth = 1;
    while(queue.length) {
        let levelSize = queue.length;
        for(let i=0; i<levelSize; i++){
            let cur = queue.shift();
            if(!cur.left&&!cur.right) return depth;
            if(cur.left) queue.push(cur.left);
            if(cur.right) queue.push(cur.right);
        }
        //该层元素全部取出
        depth++
    }
};
```

