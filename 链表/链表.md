## 链表

### 141. 环形链表

给你一个链表的头节点 `head` ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：`pos` 不作为参数进行传递** 。仅仅是为了标识链表的实际情况。

*如果链表中存在环* ，则返回 `true` 。 否则，返回 `false` 。

#### 方法一：哈希表

- 使用哈希表存放遍历过的节点，每遍历一个节点，都要查看哈希表中是否存在此节点。如果存在，则说明有环。
- 不存在，则存入哈希表中，继续遍历。
- 时间复杂度为O(0)，空间复杂度为O(0)
- 哈希表中存放的是节点，并不是节点值！

```js
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
    const map = new Map();
    let s = head
    while(s) {
        if(map.has(s)) return true;
        map.set(s, true);
        s=s.next;
    }
    return false
};
```

#### 方法二：快慢指针

- 慢指针slow：每次走1步
- 块指针fast：每次走2步
- 无环：fast最先到达链表尾部，返回false
- 有环：fast和slow会在环内相遇
  - 设slow到达环口时，slow和fast之间的距离为k（fast追slow的距离），环长度为c
    - fast在slow的后面：fast每次会比slow多走一步，距离会逐步减1，到0为止
    - fast在slow的前面：fast套圈走在了slow的前面，fast每走一次都是在追slow。最坏情况下k=c-1，最多经过c次移动，fast就会追上slow

```js
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
    let s=head, f=head;
    while(f!==null&&f.next!==null){
        s=s.next;
        f=f.next.next;
        if(s===f) return true;
    }
    return false;
};
```

### 206. 反转链表

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

####  方法一：迭代

- 在遍历链表时，将当前节点的next指针指向它的前一个节点。前一个节点需要事先存储，在更改引用之前还需要存储后一个节点，用于处理下一个结点。最终返回新的头引用。

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
    let prev = null, cur=head;
    while(cur) {
        const next = cur.next;
        cur.next=prev;
        prev=cur;
        cur=next;
    }
    return prev;
};
```

### 142. 环形链表 II

给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

**不允许修改** 链表。

#### 方法一：哈希表

- 遍历找到一个已经存在哈希表中的节点，这个节点就是环入口节点

```js
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var detectCycle = function(head) {
    let s=head;
    let map=new Map();
    while(s!==null&&s.next!==null){
        if(map.has(s)) return s;
        map.set(s,true);
        s=s.next;
    }
    return null;
};
```

#### 方法二：快慢指针

- <img src="C:\Users\86137_hr4wcni\AppData\Roaming\Typora\typora-user-images\image-20251017195422638.png" alt="image-20251017195422638" style="zoom:50%;" />

- 设头节点到环口的距离为a，环口到相遇点的距离为b，相遇点到环口的距离为c，环长为b+c

- 相遇点：

  - slow指针走过的距离为：a+b

  - fast指针走过的距离为：a+n(b+c)+b -> a+(n+1)b+nc

- fast走过的距离为slow的两倍：a+(n+1)b+nc = 2(a+b) -> a=c+(n-1)(b+c)

- 链表头到环口的距离 = 相遇点到环口的距离+(n-1)圈的环长

- 额外用一个指针指向头节点，和slow每次向后移动一个位置，最终会在环口相遇

```js
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var detectCycle = function(head) {
    let s=head,f=head
    while(f!==null&&f.next!==null){
        s=s.next
        f=f.next.next
        if(f===s) {
            s=head
            while(f!==s){
                f=f.next
                s=s.next
            }
            return f
        }
    }
    return null
};
```

### 202. 快乐数

编写一个算法来判断一个数 `n` 是不是快乐数。

**「快乐数」** 定义为：

- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
- 如果这个过程 **结果为** 1，那么这个数就是快乐数。

如果 `n` 是 *快乐数* 就返回 `true` ；不是，则返回 `false` 。

#### 方法一：哈希表

- 可能出现的情况：
  - 结果为1
  - 结果进入循环
  - 无限大（不处理）

```js
/**
 * @param {number} n
 * @return {boolean}
 */
var isHappy = function(n) {
    let map = new Map()
    let s = n;
    while(s!==1 && !map.has(s)) {
        map.set(s,true);
        s=getSum(s);
    }
    return s===1;
};

var getSum = function(n) {
    let s = String(n).split("")
    return s.reduce((sum,num)=>sum+(+num)**2,0)
}
```

#### 方法二：快慢指针

- 存在环->不是快乐数
- 不存在环：f先到达链表尾部

```js
/**
 * @param {number} n
 * @return {boolean}
 */
var isHappy = function(n) {
    let s=n, f=getSum(s);
    while(f!==1&&f!==s){
        s=getSum(s);
        f=getSum(getSum(f));
    }
    return f===1;
};
```

### 92. 反转链表 II

给你单链表的头指针 `head` 和两个整数 `left` 和 `right` ，其中 `left <= right` 。请你反转从位置 `left` 到位置 `right` 的链表节点，返回 **反转后的链表** 。

#### 方法一：穿针引线

- 使用206. 反转链表的方法，先记录left的前一个节点和后一个节点，再对left-right的节点进行反转，最后进行拼接

```js
/**
 * @param {ListNode} head
 * @param {number} left
 * @param {number} right
 * @return {ListNode}
 */
var reverseBetween = function(head, left, right) {
    const dummyNode=new ListNode(-1);
    dummyNode.next = head;
    let pre=dummyNode;
    //找到left节点的前一个节点
    for(let i =0; i< left-1; i++){
        pre=pre.next;
    }
    //找到right节点
    let rightNode = pre
    for(let i=0; i<right-left+1; i++){
        rightNode=rightNode.next;
    }

    let leftNode=pre.next; //left节点
    let cutNode = rightNode.next; //保存右边截断的节点
    //截断
    pre.next=null;
    rightNode.next=null;
    //反转
    reverseList(leftNode);
    //拼接
    pre.next=rightNode;
    leftNode.next=cutNode;
    return dummyNode.next;
};

var reverseList = function(head) {
    let prev=null;
    let cur=head;
    while(cur!==null){
        const next = cur.next;
        cur.next=prev;
        prev=cur;
        cur=next;
    }
}
```

#### 方法二：一次遍历「穿针引线」反转链表

- 在需要反转的区间里，每遍历到一个节点，让这个节点来到反转部分的起始位置

<img src="C:\Users\86137_hr4wcni\AppData\Roaming\Typora\typora-user-images\image-20251017210245685.png" alt="image-20251017210245685" style="zoom:25%;" />

```js
/**
 * @param {ListNode} head
 * @param {number} left
 * @param {number} right
 * @return {ListNode}
 */
var reverseBetween = function(head, left, right) {
    const dummyNode=new ListNode(-1);
    dummyNode.next = head;
    let pre=dummyNode;
    //找到left节点
    for(let i=0; i<left-1; i++){
        pre=pre.next;
    }
    //开始反转
    let cur=pre.next;
    for(let i=0; i<right-left;i++){
        const next=cur.next;
        cur.next=next.next;
        next.next=pre.next;
        pre.next=next;
    }
    return dummyNode.next;
};
```

### 25. K个一组翻转列表

给你链表的头节点 `head` ，每 `k` 个节点一组进行翻转，请你返回修改后的链表。

`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

#### 方法一：迭代

<img src="C:\Users\86137_hr4wcni\AppData\Roaming\Typora\typora-user-images\image-20251018165113911.png" alt="image-20251018165113911" style="zoom: 50%;" />

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */
var reverseKGroup = function(head, k) {
    let dummyNode = new ListNode(-1);
    dummyNode.next=head;
    let prev=dummyNode;
    let end=dummyNode;
    while(end.next!==null) {
        for(let i=0;i<k&&end!==null;i++) {
            end=end.next;
        }
        if(end===null) break;
        let start=prev.next;
        let nextGroup=end.next;
        //断开
        end.next=null;
        //翻转
        prev.next=myReverse(start);
        start.next=nextGroup;
        //更新指针
        prev=start;
        end=start;
    }
    return dummyNode.next;
};

var myReverse = function(head){
    let prev=null,cur=head;
    while(cur){
        const next=cur.next;
        cur.next=prev;
        prev=cur;
        cur=next;
    }
    return prev;
}
```

### 83. 删除排序链表中的重复元素

给定一个已排序的链表的头 `head` ， *删除所有重复的元素，使每个元素只出现一次* 。返回 *已排序的链表* 。

**示例 1：**

```
输入：head = [1,1,2]
输出：[1,2]
```

**示例 2：**

```
输入：head = [1,1,2,3,3]
输出：[1,2,3]
```

#### 方法一： 一次遍历

- 每次判断当前节点的val是否和下一节点的val相等
  - 相等：跳过下一节点，cur节点指向下一节点的next节点
  - 不相等：cur继续遍历

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var deleteDuplicates = function(head) {
    if(!head) return head
    let cur=head
    while(cur.next){
        if(cur.val===cur.next.val){
            cur.next=cur.next.next
        } else {
            cur=cur.next
        }
    }
    return head
};
```

### 21. 合并两个有序链表

#### 方法一：迭代

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} list1
 * @param {ListNode} list2
 * @return {ListNode}
 */
var mergeTwoLists = function(list1, list2) {
    let prehead = new ListNode(-1);
    let prev=prehead;
    while(list1!==null&&list2!==null){
        if(list1.val <= list2.val) {
            prev.next=list1;
            list1=list1.next;
        } else {
            prev.next = list2;
            list2=list2.next;
        }
        prev = prev.next
    }

    prev.next = list1 === null ? list2 : list1;
    return prehead.next;
};
```

