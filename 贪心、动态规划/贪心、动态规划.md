## 贪心、动态规划

### 55. 跳跃游戏

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

**示例 1：**

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

**示例 2：**

```
输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
```

#### 方法一：贪心算法

```js
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canJump = function(nums) {
    if(nums.length===1) return true;
    let far=nums[0];
    for(let i=1;i<nums.length;i++){
        if(i>far) return false;
        far = Math.max((nums[i]+i),far)
    }
    return true;
};
```

### 45. 跳跃游戏II

给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置在下标 0。

每个元素 `nums[i]` 表示从索引 `i` 向后跳转的最大长度。换句话说，如果你在索引 `i` 处，你可以跳转到任意 `(i + j)` 处：

- `0 <= j <= nums[i]` 且
- `i + j < n`

返回到达 `n - 1` 的最小跳跃次数。测试用例保证可以到达 `n - 1`。

**示例 1:**

```
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

**示例 2:**

```
输入: nums = [2,3,0,1,4]
输出: 2
```

#### 方法一：贪心-正向求解

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var jump = function(nums) {
    let far=0; // 当前跳跃到达的最远位置
    let end=0; // 下一次跳跃到达的最远位置
    let count=0;
    for(let i=0;i<nums.length-1;i++){
        far=Math.max(far,i+nums[i])
        if(i===end){
            count++;
            end=far;
        }
    }
    return count;
};
```

#### 方法二：贪心-反向求解

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var jump = function(nums) {
    let count=0;
    let position=nums.length-1;
    
    while(position>0){
        for(let i=0;i<nums.length;i++){
            if(i+nums[i]>=position){
                position=i;
                count++;
                break;
            }
        }
    }
    
    return count;
};
```

### 452. 用最少数量的箭引爆气球

有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 `points` ，其中`points[i] = [xstart, xend]` 表示水平直径在 `xstart` 和 `xend`之间的气球。你不知道气球的确切 y 坐标。

一支弓箭可以沿着 x 轴从不同点 **完全垂直** 地射出。在坐标 `x` 处射出一支箭，若有一个气球的直径的开始和结束坐标为 `xstart`，`xend`， 且满足  `xstart ≤ x ≤ xend`，则该气球会被 **引爆** 。可以射出的弓箭的数量 **没有限制** 。 弓箭一旦被射出之后，可以无限地前进。

给你一个数组 `points` ，*返回引爆所有气球所必须射出的 **最小** 弓箭数* 。

**示例 1：**

```
输入：points = [[10,16],[2,8],[1,6],[7,12]]
输出：2
解释：气球可以用2支箭来爆破:
-在x = 6处射出箭，击破气球[2,8]和[1,6]。
-在x = 11处发射箭，击破气球[10,16]和[7,12]。
```

**示例 2：**

```
输入：points = [[1,2],[3,4],[5,6],[7,8]]
输出：4
解释：每个气球需要射出一支箭，总共需要4支箭。
```

**示例 3：**

```
输入：points = [[1,2],[2,3],[3,4],[4,5]]
输出：2
解释：气球可以用2支箭来爆破:
- 在x = 2处发射箭，击破气球[1,2]和[2,3]。
- 在x = 4处射出箭，击破气球[3,4]和[4,5]。
```

#### 方法一：排序+贪心

```js
/**
 * @param {number[][]} points
 * @return {number}
 */
var findMinArrowShots = function(points) {
    if(!points.length) return 0;

    let count=1;
    
    points.sort((a,b)=>a[1]-b[1]);
    let pos=points[0][1];
    for(let balloon of points){
        if(balloon[0]>pos){
            count++
            pos=balloon[1]
        }
    }
    return count;
};
```

### 435. 无重叠区间

给定一个区间的集合 `intervals` ，其中 `intervals[i] = [starti, endi]` 。返回 *需要移除区间的最小数量，使剩余区间互不重叠* 。

**注意** 只在一点上接触的区间是 **不重叠的**。例如 `[1, 2]` 和 `[2, 3]` 是不重叠的。

**示例 1:**

```
输入: intervals = [[1,2],[2,3],[3,4],[1,3]]
输出: 1
解释: 移除 [1,3] 后，剩下的区间没有重叠。
```

**示例 2:**

```
输入: intervals = [ [1,2], [1,2], [1,2] ]
输出: 2
解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。
```

**示例 3:**

```
输入: intervals = [ [1,2], [2,3] ]
输出: 0
解释: 你不需要移除任何区间，因为它们已经是无重叠的了。
```

#### 方法一：贪心算法

- 右端点排序：
  - 比如[1,3], [1,100]优先选择保留前面的[1, 3]，这样子可以保留的区间就更多，删除的数量就更少
  - 若使用左端点排序，会不知道要删除哪个

```js
/**
 * @param {number[][]} intervals
 * @return {number}
 */
var eraseOverlapIntervals = function(intervals) {
    intervals.sort((a,b)=>a[1]-b[1]);
    let count=0;
    let prevend=intervals[0][1];
    for(let i=1;i<intervals.length;i++) {
        if(intervals[i][0]<prevend){
            count++;
        }else{
            prevend=intervals[i][1]
        }
    }

    return count
};
```

### 649. Dota2 参议院

Dota2 的世界里有两个阵营：`Radiant`（天辉）和 `Dire`（夜魇）

Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的 **一** 项：

- **剥夺一名参议员的权利**：一名参议员可以使另一名参议员在本轮及所有后续轮次中失去所有权利。
- **宣布胜利**：如果参议员发现有权利投票的参议员都是 **同一个阵营的** ，他可以宣布胜利并决定在游戏中的有关变化。

给你一个字符串 `senate` 代表每个参议员的阵营。字母 `'R'` 和 `'D'`分别代表了 `Radiant`（天辉）和 `Dire`（夜魇）。然后，如果有 `n` 个参议员，给定字符串的大小将是 `n`。

以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。

假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 `"Radiant"` 或 `"Dire"` 。

**示例 1：**

```
输入：senate = "RD"
输出："Radiant"
解释：
第 1 轮时，第一个参议员来自 Radiant 阵营，他可以使用第一项权利让第二个参议员失去所有权利。
这一轮中，第二个参议员将会被跳过，因为他的权利被禁止了。
第 2 轮时，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人。
```

**示例 2：**

```
输入：senate = "RDD"
输出："Dire"
解释：
第 1 轮时，第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利。
这一轮中，第二个来自 Dire 阵营的参议员会将被跳过，因为他的权利被禁止了。
这一轮中，第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利。
因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利
```

#### 方法一：队列+贪心

- 若字符串出现D，首先去投掉第一个出现的R

- 维护一个队列，用于比较R和D出现的位置顺序
- 若R队列的第一个元素出现得比D队列的第一个元素早，则将R队列的第一个元素重新压会栈中，依次弹出R队列和D队列第一个元素

```js
/**
 * @param {string} senate
 * @return {string}
 */
var predictPartyVictory = function(senate) {
    const n=senate.length;
    const radiant = [], dire = [];
    for(const [i,ch] of Array.from(senate).entries()) {
        if(ch==='R') radiant.push(i);
        else dire.push(i);
    }
    while(radiant.length&&dire.length){
        if(radiant[0]<dire[0]){
            radiant.push(radiant[0]+n);
        }else{
            dire.push(dire[0]+n);
        }
        radiant.shift();
        dire.shift();
    }
    return radiant.length ? "Radiant" : "Dire"
};
```

